#!/usr/bin/env bash

# Automatically restart machine or updated services after dnf-automatic.
#
# The following is required:
#   - DNF tracer plugin and tracer
#     $ dnf install -y dnf-plugins-extras-tracer
#     http://dnf-plugins-extras.readthedocs.io/en/latest/tracer.html
#     http://tracer-package.com/
#
#   - DNF Automatic
#     $ dnf install -y dnf-automatic && systemctl enable dnf-automatic-install.timer
#     http://dnf.readthedocs.io/en/latest/automatic.html
#
#   - DNF Automatic drop-in to run this script after DNF Automatic ran
#     $ systemctl edit dnf-automatic-install.service
#
#     Enter the following contents:
#
#     [Service]
#     # Path to this script.
#     ExecStartPost=/usr/local/sbin/dnf-automatic-restart
#
# The activity of this script can be monitored using
# $ journalctl --unit dnf-automatic-install.service

set -euo pipefail

show_help() {
  cat << EOF
Usage: ${0##*/} [-d] [-h] [-n HOURS] [-r HOUR]

Automatically restart machine or updated services after dnf-automatic.

    -d        disable reboot
    -h        display this help and exit
    -n HOURS  no automatic reboot between hours (e.g. 8-22)
    -r HOUR   schedule automatic reboot at hour (e.g. 0)
EOF
}

error() {
  >&2 printf 'Error: %s\n' "$1"
  show_help >&2
  exit "${2:-1}"
}

trigger_reboot() {
  if [[ "$disable_reboot" = true ]]; then
    >&2 printf 'Rebooting is disabled\n'
    return
  fi

  if [[ -n "$no_reboot_from" && -n "$no_reboot_to" ]]; then
    hour="$(date +%k)"

    if ((hour >= no_reboot_from && hour <= no_reboot_to)); then
      printf 'Rebooting the system is disallowed right now\n'

      if [[ -z "$reboot_at" ]]; then
        >&2 printf 'Skipped scheduling reboot because reboot time was not specified\n'
        return
      fi

      printf 'Scheduling reboot at %s:00\n' "$reboot_at"
      reboot_at="${reboot_at}:00"
    else
      printf 'Rebooting system\n'
      reboot_at=now
    fi
  elif [[ -n "$reboot_at" ]]; then
    printf 'Scheduling reboot at %s:00\n' "$reboot_at"
    reboot_at="${reboot_at}:00"
  else
    printf 'Rebooting system\n'
    reboot_at=now
  fi

  if [[ "$reboot_at" == now ]]; then
    reboot_at=+5
  fi

  /sbin/shutdown --reboot "$reboot_at" 'Rebooting after dnf-automatic updates'
  exit
}

restart() {
  local command="$1"
  local reason="$2"
  declare -g daemon_reloaded
  declare -gA restarts

  if [[ -n "${restarts["$command"]-}" ]]; then
    printf '%s: %s has been executed before\n' "$reason" "$command"
    return
  fi

  if [[ -z "${daemon_reloaded-}" ]]; then
    printf 'Reloading systemd daemon configuration\n'
    systemctl daemon-reload
    daemon_reloaded=true
  fi

  printf '%s: Restarting service using %s\n' "$reason" "$command"
  local status
  $command && status=$? || status=$?
  restarts["$command"]="$status"

  if ((status > 0)); then
    >&2 printf '%s failed with exit code %s\n' "$command" "$status"
  fi
}

OPTIND=1 # Reset is necessary if getopts was used previously in the script.
numeric='^[0-9]+$'
disable_reboot=false
no_reboot_from=
no_reboot_to=
reboot_at=
while getopts ':dhn:r:' opt; do
  case "$opt" in
      d)
        disable_reboot=true
        ;;
      h)
        show_help
        exit 0
        ;;
      n)
        no_reboot_from=${OPTARG%%-*}
        no_reboot_to=${OPTARG##*-}

        if ! [[ $OPTARG =~ '-' ]]; then
          error 'No automatic reboot between hours must be a range separated by minus (-)'
        fi

        if ! [[ $no_reboot_from =~ $numeric && $no_reboot_to =~ $numeric ]]; then
          error 'No automatic reboot between hours must be numeric.'
        fi

        if ((no_reboot_to < no_reboot_from)); then
          error 'No automatic reboot between hours must be a valid "from-to" range.'
        fi
        ;;
      r)
        reboot_at="$(printf %02d "$OPTARG")"

        if ! [[ $reboot_at =~ $numeric ]]; then
          error 'Reboot at hour must be numeric.'
        fi
        ;;
      :)
        error "Option -$OPTARG requires an argument."
        ;;
      '?')
        error "Invalid option: -$OPTARG"
        ;;
  esac
done

tracer_status=0
tracer_out="$(tracer)" || tracer_status=$?
if ((tracer_status > 0 && (tracer_status < 101 || tracer_status > 104))); then
  error "Tracer failed with exit code $tracer_status" "$tracer_status"
fi

printf 'tracer output:\n%s\n' "$tracer_out"

if ((tracer_status == 104)); then
  printf 'The kernel was updated\n'
  trigger_reboot
fi

for unit in systemd auditd; do
  if [[ "$tracer_out" == *$unit* ]]; then
    printf '%s was updated\n' "$unit"
    trigger_reboot
  fi
done

(tracer --services-only || true) |
  tail --lines=+3 |
  sort |
  uniq |
  while read -r command; do

  restart "$command" 'Tracer'

  if [[ "$command" == *firewalld* ]] &&
     systemctl is-active --quiet docker; then
    restart 'systemctl restart docker' \
            'Because firewalld was restarted'
  fi
done
